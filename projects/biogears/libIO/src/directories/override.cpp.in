#include <biogears/io/directories/override.h>

#include <cstring>
#include <string>
#include <fstream>

#include <biogears/filesystem/path.h>

@RESOURCE_INCLUDE_LIST@

namespace biogears {
namespace io {
  static char default_directory[] = "override/";
  char const * override_file_list[] = {
@RESOURCE_FILE_LIST@
  };

  constexpr size_t count_of_override_files = @RESOURCE_FILE_COUNT@;

  //biogears::filesystem::path overloads
  bool generate_override_directory(biogears::filesystem::path path)
  {
   biogears::filesystem::path working_dir  = path;
   std::ofstream output;

   bool result = true;

   auto write_file = [&](biogears::filesystem::path path, char const* content, size_t content_size) {
      biogears::filesystem::create_directories((working_dir / path).parent_path());
      output.open((working_dir / path).string(filesystem::path::posix_path), std::fstream::binary | std::fstream::out);
      if (output.good() && !output.is_open()) {
        return false;
      }
      output.write(content, content_size);
      output.close();
      return true;
   };
   biogears::filesystem::path dir {default_directory};
@GENERATE_DIRECTORY_BODY@

   return true;
  }
  //-----------------------------------------------------------------------------
  bool does_embedded_override_file_exist(biogears::filesystem::path path)
  {
     return @DOES_EMBEDDED_FILE_EXIST_PATH_BODY@false;
  }
  //-----------------------------------------------------------------------------
  char const* get_override_file_sha1(biogears::filesystem::path path)
  {
     char const* file_sha1 = "";
     
@GET_FILE_SHA1_PATH_BODY@

     return file_sha1;
  }
  //-----------------------------------------------------------------------------
  char const* get_embedded_override_file(biogears::filesystem::path path, size_t& content_size)
  {
    char const * embedded_content = "";

@GET_EMBEDED_CONTENTS_PATH_BODY@

    return embedded_content;
  }
  //-----------------------------------------------------------------------------
  size_t  get_embedded_override_file_size( const char* path) 
  {
    size_t size_of_embedded_content = 0;

@GET_EMBEDED_CONTENTS_SIZE_PATH_BODY@

    return size_of_embedded_content ;
  }
  //-----------------------------------------------------------------------------
  char const * get_default_override_directory() { return default_directory; }
  //-----------------------------------------------------------------------------
  
  bool generate_override_directory(const char* root)
  {
   biogears::filesystem::path working_dir { root };
   return generate_override_directory(working_dir);
  }
  //-----------------------------------------------------------------------------
  bool does_embedded_override_file_exist(const char* path)
  {
    std::string resource_id { path };
    if ( default_directory == resource_id.substr(0,sizeof(default_directory))){
      resource_id = resource_id.substr(sizeof(default_directory));
    }
    return does_embedded_override_file_exist(resource_id);
  }
  //-----------------------------------------------------------------------------
  size_t find_override_file(const char* file, const char* root, char* buffer, size_t buffer_length)
  { 
    size_t content_size = 0;
    biogears::filesystem::path test_location { file };
    if (test_location.exists() && test_location.is_file()) {
      std::ifstream override_file { test_location.str(), std::ios::in };
      if (override_file.is_open()) {
        override_file.seekg(0, override_file.end);
        content_size = override_file.tellg();
        override_file.seekg(0, override_file.beg);
      }
      if (content_size < buffer_length) {
        override_file.read(buffer, content_size);
        return content_size;
      }
    }
    if (root != nullptr) {
      test_location = root;
      test_location /= file;
      if (test_location.exists() && test_location.is_file()) {
        std::ifstream override_file { test_location.str(), std::ios::in };
        if (override_file.is_open()) {
          override_file.seekg(0, override_file.end);
          content_size = override_file.tellg();
          override_file.seekg(0, override_file.beg);
          if (content_size < buffer_length) {
            override_file.read(buffer, content_size);
            return content_size;
          }
        }
      }
    }

    auto embeded_content = get_embedded_override_file(file, content_size);
    if ( content_size < buffer_length )  {
      memcpy(buffer, embeded_content, content_size); 
    }
    
    return content_size;
  }
  //-----------------------------------------------------------------------------
  char const* get_override_file_sha1(const char* path)
  {
    std::string resource_id { path };
    if ( default_directory == resource_id.substr(0,sizeof(default_directory))){
      resource_id = resource_id.substr(sizeof(default_directory));
    }
    return get_override_file_sha1(resource_id);
  }
  //-----------------------------------------------------------------------------
  char const** list_override_files()
  {
    return override_file_list;
  }
  //-----------------------------------------------------------------------------
  size_t override_file_count()
  {
    return count_of_override_files;
  }
  //-----------------------------------------------------------------------------
  char const* get_embedded_override_file(const char* path, size_t& content_size)
  {
    std::string resource_id { path };
    if ( default_directory == resource_id.substr(0,sizeof(default_directory))){
      resource_id = resource_id.substr(sizeof(default_directory));
    }
    return get_embedded_override_file(resource_id, content_size);
  }
  //-----------------------------------------------------------------------------
}
}
